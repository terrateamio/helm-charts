# -- (string) Optionally override the Helm chart name.
# We prefix deployed resources with "{{ template "application.name" }}-"
# @default -- .Chart.name
applicationName:
# -- (string) Optionally override the destination namespace
namespaceOverride:


# These will be applied to all deployed resources, unless overriden
# E.g. `terrateam.labels` overrides `global.labels`
# E.g. `terrateam.service.annotations` overrides `terrateam.annotations`, which itself overrides `global.annotations`
# --
global:
  # -- Global annotations applied to all resources
  annotations: {}
  # -- Global labels applied to all resources
  labels: {}

  # -- Node selector for all pods
  nodeSelector: {}
  # -- Tolerations for all pods
  tolerations: []

  # -- Affinity rules for all pods
  affinity: {}
  # -- Security context for all pods
  securityContext: {}
  # -- Image pull secrets for all pods
  imagePullSecrets: []


# --
terrateam:
  name: server

  # -- `terrateam.annotations` merges with `global.annotations`<br><br>
  # Overrides `global.annotations` if conflicting
  annotations: {}

  # -- `terrateam.labels` merges with `global.labels`<br><br>
  # Overrides `global.labels` if conflicting
  # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
  labels: {}

  config:

    # -- The FQDN of your Terrateam API reachable from your GitHub Actions
    # @section -- Terrateam Required Values
    fqdn: &terrateam_fqdn "terrateam.example.com"

    # -- If the Terrateam API is configured to listen on a custom endpoint, perhaps with URL rewrites or over HTTP instead of HTTPS,
    # you can override the API's URL
    # @default -- `https://{{ .Values.terrateam.config.fqdn }}/api`
    apiEndpoint: ""

    # -- The public-facing web base URL.
    # MUST be prefixed with `https://`
    # @default -- `https://{{ .Values.terrateam.config.fqdn }}`
    webBaseUrl: ""

    # -- Public-facing UI base URL (required for UI).
    # MUST be prefixed with `https://` or GitHub webhook events to Terrateam will error
    # @default -- `https://{{ .Values.terrateam.config.fqdn }}`
    uiBase: ""

    # -- Set the level of telemetry data reported back to Terrateam
    telemetryLevel: "anonymous"

    db:
      # -- If db.enabled = true, set `terrateam.config.db.hostname` to the same value as `db.name`.<br><br>
      # If your PostgreSQL server is deployed in the same Kubernetes cluster, you can reference it's Service<br>
      #   E.g. `postgres.postgres-namespace.svc.cluster.local:5432`<br>
      # Otherwise, for externally-accessible PostgreSQL servers use the FQDN<br>
      #   E.g. `my-hostname.postgres.database.azure.com`
      # @section -- Terrateam Required Values
      hostname: terrateam-db

      # -- PostgreSQL uses port `5432` by default
      port: 5432

      # -- The PostgreSQL username to log in with
      # @section -- Terrateam Required Values
      username: terrateam

      # -- The PostgreSQL data to log into
      # @section -- Terrateam Required Values
      databaseName: terrateam

      # -- The PostgreSQL password must be stored in a Kubernetes secret.<br><br>
      # You can manually create the secret with `kubectl`, or Terraform it with `resource.kubernetes_secret_v1`,
      # or use external-secrets to pull the value from a Vault
      passwordSecretName: terrateam-db-password
      # -- The Kubernetes Secret's key containing the PostgreSQL password
      passwordSecretKey: password

    github:
      # -- GitHub is the default provider.
      # Set this to `false` to use GitLab instead
      enabled: true

      # -- The name of the Kubernetes secret containing the GitHub app's id
      appIdSecretName: terrateam-github-app-id
      # -- The name of the key in the Kubernetes secret containing the GitHub app's id
      appIdSecretKey: id

      # -- The name of the Kubernetes secret containing the GitHub app's client id
      appClientIdSecretName: terrateam-github-app-client-id
      # -- The name of the key in the Kubernetes secret containing the GitHub app's client id
      appClientIdSecretKey: id

      # -- The name of the Kubernetes secret containing the GitHub app's client secret
      appClientSecretSecretName: terrateam-github-app-client-secret
      # -- The name of the key in the Kubernetes secret containing the GitHub app's client secret
      appClientSecretSecretKey: secret

      # -- The name of the Kubernetes secret containing the GitHub app's private PEM certificate
      appPrivatePemCertificateSecretName: terrateam-github-app-pem
      # -- The name of the key in the Kubernetes secret containing the GitHub app's private PEM certificate
      appPrivatePemCertificateSecretKey: pem

      # -- The name of the Kubernetes secret containing the GitHub app's webhook secret
      webhookSecretName: terrateam-github-webhook-secret
      # -- The name of the key  in the Kubernetes secret containing the GitHub app's webhook secret
      webhookSecretKey: secret

      # -- The GitHub App URL (e.g., https://github.com/apps/your-app-name)
      # This is the public URL where your GitHub App can be accessed
      appUrl: ""

      # -- GitHub API base URL (for GitHub Enterprise)
      # @default -- "https://api.github.com" for GitHub.com
      apiBaseUrl: ""

      # -- GitHub web base URL (for GitHub Enterprise)
      # @default -- "https://github.com" for GitHub.com
      webBaseUrl: ""

    gitlab:
      # -- Optionally use GitLab.
      # Must also set `terrateam.config.github.enabled` to `false` to use GitLab
      enabled: false

      # -- The name of the Kubernetes secret containing the GitLab app's id
      appIdSecretName: terrateam-gitlab-app-id
      # -- The name of the key in the Kubernetes secret containing the GitLab app's id
      appIdSecretKey: id

      # -- The name of the Kubernetes secret containing the GitLab app's secret
      appSecretSecretName: terrateam-gitlab-app-secret
      # -- The name of the key in the Kubernetes secret containing the GitLab app's secret
      appSecretSecretKey: secret

      # -- The name of the Kubernetes secret containing the GitLab private access token
      accessTokenSecretName: terrateam-gitlab-access-token
      # -- The name of the key in the Kubernetes secret containing the GitLab app's private access token
      accessTokenSecretKey: token

      # -- GitLab API base URL (for self-hosted GitLab)
      # @default -- "https://gitlab.com/api" for GitLab.com
      apiBaseUrl: ""

      # -- GitLab web base URL (for self-hosted GitLab)
      # @default -- "https://gitlab.com" for GitLab.com
      webBaseUrl: ""

    infracost:
      # -- If self-hosting Infracost, this is the endpoint used to query your self-hosted Infracost API.<br>
      # E.g. `http://infracost-cloud-pricing-api.infracost.svc.cluster.local:80`
      pricingApiEndpoint: ""

      # -- This is the 32-character API key you created for clients like Terrateam to consume
      selfHostedApiKey: ""

    # -- Optionally pass extra environment variables into the Terrateam container
    # https://docs.terrateam.io/self-hosted/instructions#environment-variables-1
    extraEnv: {}

  image:
    # -- Repository containing the Terrateam image to deploy
    repository: ghcr.io/terrateamio/terrat-oss

    # -- For production use it is recommended that you pin a [specific tag](https://github.com/terrateamio/terrateam/pkgs/container/terrat-oss/versions)
    tag: "latest"

    # -- Set this to `Always` if `terrateam.image.tag` = `latest` to bust the Kubernetes image cache
    pullPolicy: Always

  # -- `terrateam.imagePullSecrets` merges with `global.imagePullSecrets`<br><br>
  # Overrides `global.imagePullSecrets` if conflicting
  imagePullSecrets: []

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi


  service:
    # -- A Service for Terrateam is deployed by default
    enabled: true

    # -- The name of the Service created for Terrateam.
    # Defaults to `terrateam.name` if undefined
    name: ""

    # -- `terrateam.service.annotations` merges with `global.annotations` & `global.terrateam.annotations`<br><br>
    # Overrides `global.annotations` & `global.terrateam.annotations` if conflicting
    annotations: {}

    # -- `terrateam.service.labels` merges with `global.labels` & `global.terrateam.labels`<br><br>
    # Overrides `global.labels` & `global.terrateam.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
    labels: {}

    # -- ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # -- The port the service will expose
    port: 8080

    # -- NodePort should only be defined if `terrateam.service.type` = `"NodePort"`.<br>
    # If undefined, Kubernetes will pick a random port in the `30000`-`32767` range
    nodePort: ""

  autoscaler:
    # -- Optionally deploy a HorizontalPodAutoscaler.
    # Supersedes `.Values.terrateam.replicaCount`
    enabled: false
    name: "hpa"

    # -- The minimum number of replicas to deploy.<br><br>
    # During initial install, we recommend deploying a single pod for DB migrations to succeed. You can increase the replicas after the initial DB migration successfully completes.
    minReplicas: 1

    # -- The maximum number of replicas to deploy.<br><br>
    # During initial install, we recommend deploying a single pod for DB migrations to succeed. You can increase the replicas after the initial DB migration successfully completes.<br><br>
    # Note: setting maxReplicas = minReplicas can trigger Alertmanager HPA maxed alerts
    maxReplicas: 1

    # -- The metrics to use to calculate scaling operations
    # @default -- 60% CPU & memory utilization
    metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 60
      - type: Resource
        resource:
          name: memory
          target:
            type: Utilization
            averageUtilization: 60

    # -- The operations to apply after calculating scaling metrics
    behavior: {}

  # -- Number of Terrateam pods to deploy.<br><br>
  # Terrateam horizontally scales, you are effectively [limited by your DB's available resources](https://docs.terrateam.io/self-hosted/best-practices/#scaling-considerations)<br><br>
  # This field is ignored if `.Values.terrateam.autoscaling` = `true`
  replicaCount: 1

  # -- Maximum number of historical ReplicaSets to keep.
  # This can be useful for troubleshooting previous failed deployments
  revisionHistoryLimit: 2

  # -- Readiness probe.
  # @default -- See below
  readinessProbe:
    # -- Enable Readiness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- Liveness probe.
  # @default -- See below
  livenessProbe:
    # -- Enable Liveness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- `terrateam.nodeSelector` merges with `global.nodeSelector`<br><br>
  # Overrides `global.nodeSelector` if conflicting
  nodeSelector: {}
  # -- `terrateam.tolerations` merges with `global.tolerations`<br><br>
  # Overrides `global.tolerations` if conflicting
  tolerations: []

  # -- `terrateam.affinity` merges with `global.affinity`<br><br>
  # Overrides `global.affinity` if conflicting
  affinity: {}
  # -- `terrateam.securityContext` merges with `global.securityContext`<br><br>
  # Overrides `global.securityContext` if conflicting
  securityContext: {}


# --
ingress:
  # -- Optionally create an Nginx ingress
  enabled: false
  name: &ingress_name "ingress"

  # -- `ingress.annotations` merges with `global.annotations`<br><br>
  # Overrides `global.annotations` if conflicting
  annotations: {}

  # -- `ingress.labels` merges with `global.labels`<br><br>
  # Overrides `global.labels` if conflicting
  # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
  labels: {}

  # -- The IngressClass to use when creating the Ingress
  className: "nginx"

  # -- The name of the Kubernetes Secret containing the private TLS certificate protecting the Ingress
  tlsSecretName: &ingress_secret_name "terrateam-tls"

  certificate:
    # -- Optionally generate a TLS certificate for your ingress
    enabled: false

    # -- Defaults to `{ingress.name}-certificate` if undefined
    name: ""

    # -- `ingress.certificate.annotations` merges with `global.annotations` & `ingress.annotations`<br><br>
    # Overrides `global.annotations` & `ingress.annotations` if conflicting
    annotations: {}
    # -- `ingress.certificate.labels` merges with `global.labels` & `ingress.labels`<br><br>
    # Overrides `global.labels` & `ingress.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
    labels: {}

    apiVersion: ""
    kind: ""

    # cert-manager example:
    # apiVersion: cert-manager.io/v1
    # kind: Certificate
    # spec:
    #   secretName: *ingress_secret_name
    #   dnsNames:
    #     - *terrateam_fqdn
    #   issuerRef:
    #     name: letsencrypt-prod
    #     kind: ClusterIssuer

    # GKE example:
    # apiVersion: networking.gke.io/v1
    # kind: ManagedCertificate
    # spec:
    #   domains:
    #     - *terrateam_fqdn
    # -- The complete spec section for the certificate, allows full flexibility for any certificate provider
    spec: {}


##
## For convenience and testing, we include a PostgreSQL database deployment to store Terrateam data.
## You might want to consider a more robust solution hosted by a cloud provider or
## a dedicated PostgreSQL deployment with HA
##
# --
db:
  # -- Optionally deploy a self-contained PostgreSQL server.
  # Set to `false` to use an external PostgreSQL server
  enabled: true

  # -- The name of the PostgreSQL server pod
  name: db

  # -- `db.annotations` merges with `global.annotations`<br><br>
  # Overrides `global.annotations` if conflicting
  annotations: {}

  # -- `db.labels` merges with `global.labels`<br><br>
  # Overrides `global.labels` if conflicting
  # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.db.name }}`
  labels: {}

  # These affect the environment variables injected into the PostgreSQL server container
  config:
    # -- PostgreSQL uses port `5432` by default
    port: 5432

    # -- The name of the database to create inside the PostgreSQL server.
    # Remember to update `terrateam.db.databaseName` with this value
    databaseName: terrateam

    # -- The name of the admin user to create.
    # Remember to update `terrateam.db.username` with this value
    username: terrateam

    # -- The password of the admin user to create is derived from a Kubernetes secret.<br><br>
    # You can manually create the secret with `kubectl`, or Terraform it with `resource.kubernetes_secret_v1`,
    # or use external-secrets to pull the value from a Vault
    passwordSecretName: terrateam-db-password
    # -- The Kubernetes Secret's key containing the PostgreSQL password
    passwordSecretKey: password

    # -- Optionally pass [extra environment variables](https://www.postgresql.org/docs/14/libpq-envars.html) into the PostgreSQL server container
    extraEnv: {}

  image:
    repository: postgres
    tag: "14.18-alpine"
    pullPolicy: IfNotPresent
  imagePullSecrets: []

  # You may want to tune these depending on how many concurrent runs Terrateam serves
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi

  # Persistent DB storage settings
  pvc:
    name: db-data-claim

    # -- `db.pvc.annotations` merges with `global.annotations` & `global.db.annotations`<br><br>
    # Overrides `global.annotations` & `global.db.annotations` if conflicting
    annotations: {}

    # -- `db.pvc.labels` merges with `global.labels` & `db.labels`<br><br>
    # Overrides `global.labels` & `db.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.db.name }}`
    labels: {}

    # -- The size of the PV requested by the PVC to ensure data persistence
    storageSize: 1Gi

    # -- The name of the StorageClass that provides the PersistentVolume.
    # Most Kubernetes clusters use a `"default"` StorageClass when undefined
    storageClassName: ""

  service:
    # -- The name of the Service created for the PostgreSQL server.
    # Defaults to `db.name` if undefined
    name: ""

    # -- `db.service.annotations` merges with `global.annotations` & `global.db.annotations`<br><br>
    # Overrides `global.annotations` & `global.db.annotations` if conflicting
    annotations: {}

    # -- `db.service.labels` merges with `global.labels` & `global.db.labels`<br><br>
    # Overrides `global.labels` & `global.db.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
    labels: {}

    # -- ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # -- (int) The port the service will expose
    # Defaults to `db.config.port` if undefined
    port:

    # -- (int) `NodePort` should only be defined if `db.service.type` = `"NodePort"`<br>
    # If undefined, Kubernetes will pick a random port in the `30000`-`32767` range
    nodePort:

  # -- Readiness probe.
  # @default -- See below
  readinessProbe:
    # -- Enable Readiness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- Liveness probe.
  # @default -- See below
  livenessProbe:
    # -- Enable Liveness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- Maximum number of historical ReplicaSets to keep.
  # This can be useful for troubleshooting previous failed deployments
  revisionHistoryLimit: 2

  # -- `db.nodeSelector` merges with `global.nodeSelector`<br><br>
  # Overrides `global.nodeSelector` if conflicting
  nodeSelector: {}
  # -- `db.tolerations` merges with `global.tolerations`<br><br>
  # Overrides `global.tolerations` if conflicting
  tolerations: []

  # -- `db.affinity` merges with `global.affinity`<br><br>
  # Overrides `global.affinity` if conflicting
  affinity: {}
  # -- `db.securityContext` merges with `global.securityContext`<br><br>
  # Overrides `global.securityContext` if conflicting
  securityContext: {}


# --
rbac:
  # -- Optionally enable RBAC, attaching a ServiceAccount with a Role & RoleBinding to the deployments
  enabled: true
  serviceAccount:
    # -- Optionally deploy a ServiceAccount
    enabled: true

    # -- ServiceAccount name
    # @default -- `{{ include "application.name" $ }}`
    name: ""

    # -- `db.service.annotations` merges with `global.annotations` & `global.db.annotations`<br><br>
    # Overrides `global.annotations` & `global.db.annotations` if conflicting
    annotations: {}

    # -- `db.service.labels` merges with `global.labels` & `global.db.labels`<br><br>
    # Overrides `global.labels` & `global.db.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.terrateam.name }}`
    labels: {}

  # -- Namespaced Roles
  roles:
    - name: secrets
      rules:
      - apiGroups:
        - ""
        resources:
        - secrets
        verbs:
        - get
  # - name: configmaps
  #   rules:
  #   - apiGroups:
  #     - ""
  #     resources:
  #     - configmaps
  #     verbs:
  #     - get
